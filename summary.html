<!DOCTYPE html>
<html><head><title>Protocol/Implementation summary</title><link href="http://yui.yahooapis.com/pure/0.2.0/pure-min.css" rel="stylesheet" type="text/css"><link href="http://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet" type="text/css"></head><body style="padding: 0 2em;"><div class="pure-g"><div class="pure-u-1"><h2>Protocol/Implementation summary</h2><p>git hash: <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647">dc0f3d66ad7c48493f4110fc15621a7d0f817647</a></p><small>Hint: hover on protocol or implementation names to get their description</small></div><div class="pure-u-1"><table class="pure-table"><thead><th><th><span>vectorz</span></th><th><span title="An implementation of strided N-Dimensional array">ndarray</span></th><th><span title="An implementation of strided N-Dimensional array">ndarray-double</span></th><th><span title="An implementation of strided N-Dimensional array">ndarray-float</span></th><th><span title="An implementation of strided N-Dimensional array">ndarray-long</span></th><th><span title="Implementation for nested Clojure persistent vectors used as matrices">persistent-vector</span></th><th><span title="Core.matrix implementation enabling a map with appropriate metadata to be used as a core.matrix implementation.">persistent-map</span></th><th><span title="Core.matrix implementation for Clojure ISeq objects">sequence</span></th><th><span title="Clojure.core.matrix implementation for Java double arrays">double-array</span></th><th><span title="Wraps a single scalar as a mutable 0-D array">scalar-wrapper</span></th><th><span title="Wraps a row-major slice of an array">slice-wrapper</span></th><th><span title="Wraps an N-dimensional subset or broadcast of an array">nd-wrapper</span></th></thead><tbody><tr class="pure-table-odd"><td><span title="Protocol for general implementation functionality. Required to support implementation metadata and matrix construction.">PImplementation</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L24">24</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol to return standard dimension information about an array. dimensionality and dimension-count are mandatory for implementations">PDimensionInfo</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L47">47</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol for indexed read access to arrays, matrices and vectors. Indexing values can be assumed to be integers. indexes may be any sequence or Java array of index values.">PIndexedAccess</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L67">67</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol for indexed 'setter' operations. These are like Clojure's 'assoc' function, i.e. they return an updated copy of the original array, which is itself unchanged. Must be supported for any immutable array type.">PIndexedSetting</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L74">74</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol for indexed mutable setter access to matrices and vectors. Must be supported for any mutable matrix type.">PIndexedSettingMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L90">90</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for cloning a matrix value. The new clone must be mutable if the original matrix is mutable, i.e. mutating the clone must not affect the original. The copy should be shallow, if applicable.">PMatrixCloning</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L97">97</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for querying the type of matrix elements. If not provided, the default implementation will return java.lang.Object, and the matrix object must accept any type of value. If a matrix is primitive-backed, it should return the appropriate primitive type e.g. Double/TYPE.">PTypeInfo</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L125">125</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for creating a mutable copy of a matrix. If implemented, must return either a fully mutable copy of the given matrix, or nil if not possible. The default implementation will attempt to choose a suitable mutable matrix implementation.">PMutableMatrixConstruction</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L131">131</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span>PZeroDimensionConstruction</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L138">138</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for accessing the scalar value in zero-dimensional arrays. Zero dimensional arrays differ from scalar values in the following two senses: - They may be mutable (in which case set-0d! is expected to work) - They are not considered themselves to be scalars. Hence you must use get-0d to access the contained scalar value">PZeroDimensionAccess</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L144">144</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol for setting the scalar value in zero-dimensional arrays.">PZeroDimensionSet</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L153">153</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for construction of special matrices.">PSpecialisedConstructors</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L157">157</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to coerce a parameter to a format usable by a specific implementation. It is up to the implementation to determine what parameter types they support. If the implementation is unable to perform coercion, it must return nil. Implementations must also be able to coerce valid scalar values (presumably to themselves...)">PCoercion</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L162">162</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support broadcasting over one or more dimensions.">PBroadcast</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L171">171</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to broadcast into a given matrix shape. May also perform coercion if needed by the implementation.">PBroadcastLike</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L185">185</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to allow conversion to Clojure-friendly vector format. Optional for implementers.">PConversion</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L189">189</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to reshape matrices. Should support any new shape allowed by the implementation. Must preserve row-major ordering of matrix elements. If the original matrix is mutable, must return a new mutable copy of data. If the new shape has less elements than the original shape, it is OK to truncate the remaining elements. If the new shape requires more elements than the original shape, should throw an exception.">PReshaping</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L193">193</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support getting slices of an array. If implemented, must return either a view, a scalar or an immutable sub-matrix: it must *not* return copied data. i.e. making a full copy must be avoided.">PMatrixSlices</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L201">201</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for getting a sub-vector view of a vector. Must return a mutable view if the original vector is mutable. Should throw an exception if the specified subvector is out of bounds for the target vector.">PSubVector</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L209">209</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol for quick view access into a row-major slices of an array. If implemented, must return either a view or an immutable sub-matrix: it must *not* return copied data. If the matrix is mutable, it must return a mutable view. The default implementation creates a wrapper view.">PSliceView</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L215">215</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Returns the row-major slices of the array as a sequence. These must be views or immutable sub-arrays. The default implementation uses get-major-slice-view to obtain the slices.">PSliceSeq</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L224">224</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for concatenating / joining arrays.">PSliceJoin</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L229">229</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for picking out subsections of a 2D matrix. Should return a mutable view if possible. The default implementation creates a new vector containing the diagonal values.">PMatrixSubComponents</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L234">234</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for assigning values element-wise to mutable arrays.">PAssignment</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L240">240</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span>PMutableFill</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L251">251</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for getting data as a double array">PDoubleArrayOutput</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L256">256</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for numerical array equality operations.">PMatrixEquality</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L265">265</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support matrix multiplication on an arbitrary matrix, vector or scalar. Implementation may return nil if the implementation does not support one of the parameters, in which case a more general operation will be attempted.">PMatrixMultiply</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L274">274</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for general inner and outer products of arrays. Products should use + and * as normally defined for numerical types">PMatrixProducts</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L282">282</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for add-product operation. Intended to implement a fast version for result = m + a * b">PAddProduct</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L288">288</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for mutable add-product! operation.">PAddProductMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L293">293</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for add-product operation. Intended to implement a fast version for result = m + a * b * factor">PAddScaledProduct</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L297">297</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for mutable add-product! operation.">PAddScaledProductMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L302">302</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for add-scaled operation. Intended to implement a fast version for result = m + a * factor">PAddScaled</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L306">306</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for mutable add-scaled! operation.">PAddScaledMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L311">311</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support element-wise division operator. One-arg version returns the reciprocal of all elements.">PMatrixDivide</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L315">315</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support mutable matrix multiplication on an arbitrary matrix, vector or scalar">PMatrixMultiplyMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L322">322</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support transformation of a vector to another vector. Is equivalent to matrix multiplication when 2D matrices are used as transformations. But other transformations are possible, e.g. affine transformations. A transformation need not be a core.matrix matrix: other types are permissible">PVectorTransform</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L327">327</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support numerical array scaling by scalar values. Provided because array classes may have efficient specialised scaling operaions. Works according the the default definition of multiplication for the matrix class (usually numerical, i.e. equivalent to clojure.core/+)">PMatrixScaling</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L336">336</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support mutable array scaling by scalar values.">PMatrixMutableScaling</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L348">348</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support addition and subtraction on arbitrary matrices">PMatrixAdd</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L353">353</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support mutable addition and subtraction">PMatrixAddMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L358">358</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to get a subarray of another array. dim-ranges should be a sequence of [start len] pairs, one for each dimension. If a pair is nil, it should be interpreted to take the whole dimension. Returning a mutable view is preferred, if the implementation supports this.">PSubMatrix</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L363">363</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to compute a matrix by calling a function on each indexed location. The function f will be called as (f x y z ...) for all index values.">PComputeMatrix</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L370">370</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for array transpose operation">PTranspose</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L375">375</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for identifying numerical arrays. Should return true if every element in the array is a valid numerical value.">PNumerical</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L384">384</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support common numerical vector operations.">PVectorOps</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L390">390</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span>PVectorCross</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L401">401</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span>PVectorDistance</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L407">407</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span>PVectorView</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L411">411</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span>PVectorisable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L416">416</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for mutable versions of common vector operations">PMutableVectorOps</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L421">421</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support common 2D numerical matrix operations">PMatrixOps</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L425">425</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span>PNegation</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L435">435</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support computing the rank (number of linearly independent rows) in a matrix">PMatrixRank</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L439">439</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support the summing of all elements in an array. The array must hold numeric values only, or an exception will be thrown.">PSummable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L444">444</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support the 'pow' function. Should raise every element of a matrix to a given exponent. Default implementation uses Java's Math/pow function which is appropriate for double values: arrays supporting arbitrary precision numbers or complex types will need to provide their own implementation.">PExponent</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L449">449</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support element-wise squaring of a numerical array.">PSquare</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L456">456</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for elementary row operations">PRowOperations</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L464">464</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support mathematic functions applied element-wise to a numerical array">PMathsFunctions</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L476">476</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support mutable mathematic functions applied element-wise to a numerical array">PMathsFunctionsMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L481">481</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to return the total count of elements in matrix. Result may be any integer type, typically a java.lang.Long">PElementCount</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L486">486</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to allow functional-style operations on matrix elements.">PFunctionalOperations</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L491">491</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for matrix predicates like identity-matrix? or zero-matrix?">PMatrixPredicates</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L515">515</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for returning the generic/default values of a matrix implementation">PGenericValues</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L531">531</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for returning the generic numerical functions of a matrix implementation">PGenericOperations</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/dc0f3d66ad7c48493f4110fc15621a7d0f817647/src/main/clojure/clojure/core/matrix/protocols.clj#L537">537</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table></div></div></body></html>