<!DOCTYPE html>
<html><!DOCTYPE html>
<html><head><title>Protocol/Implementation summary</title><link href="http://yui.yahooapis.com/pure/0.2.0/pure-min.css" rel="stylesheet" type="text/css"><link href="http://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet" type="text/css"></head><body style="padding: 0 2em;"><div class="pure-g"><div class="pure-u-1"><h2>Protocol implementation summary</h2><p>git hash: <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21">6bdb29ad4662d8845e923a2d69abfeb0c5e42c21</a></p><small>Hint: hover on protocol or implementation names to get their description</small></div><div class="pure-u-1"><table class="pure-table"><thead><th><th><span>vectorz</span></th><th><span title="An implementation of strided N-Dimensional array">ndarray</span></th><th><span title="Implementation for nested Clojure persistent vectors used as matrices">persistent-vector</span></th><th><span title="Core.matrix implementation enabling a map with appropriate metadata to be used as a core.matrix implementation.">persistent-map</span></th><th><span title="Core.matrix implementation for Clojure ISeq objects">sequence</span></th><th><span title="Clojure.core.matrix implementation for Java double arrays">double-array</span></th><th><span title="Wraps a single scalar as a mutable 0-D array">scalar-wrapper</span></th><th><span title="Wraps a row-major slice of an array">slice-wrapper</span></th><th><span title="Wraps an N-dimensional subset or broadcast of an array">nd-wrapper</span></th></thead><tbody><tr class="pure-table-odd"><td><span title="Protocol for general implementation functionality. Required to support implementation metadata and matrix construction.">PImplementation</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L24">24</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol to return standard dimension information about a matrix. dimensionality and dimension-count are mandatory for implementations">PDimensionInfo</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L47">47</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol for indexed read access to matrices and vectors.">PIndexedAccess</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L65">65</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol for indexed 'setter' operations on matrices and vectors. These are like Clojure's 'assoc' function, i.e. they return an updated copy of the original matrix, which is itself unchanged. Must be supported for any immutable matrix type.">PIndexedSetting</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L71">71</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol for indexed mutable setter access to matrices and vectors. Must be supported for any mutable matrix type.">PIndexedSettingMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L87">87</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for cloning a matrix value. The new clone must be mutable if the original matrix is mutable, i.e. mutating the clone must not affect the original.">PMatrixCloning</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L94">94</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for querying the type of matrix elements. If not provided, the default implementation will return java.lang.Object, and the matrix object must accept any type of value. If a matrix is primitive-backed, it should return the appropriate primitive type e.g. Double/TYPE.">PTypeInfo</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L122">122</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for creating a mutable copy of a matrix. If implemented, must return either a fully mutable copy of the given matrix, or nil if not possible. The default implementation will attempt to choose a suitable mutable matrix implementation.">PMutableMatrixConstruction</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L128">128</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for accessing the scalar value in zero-dimensional arrays. Zero dimensional arrays differ from scalar values in the following two senses: - They may be mutable (in which case set-0d! is expected to work) - They are not considered themselves to be scalars. Hence you must use get-0d to access the contained scalar value">PZeroDimensionAccess</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L135">135</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol for construction of special matrices.">PSpecialisedConstructors</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L144">144</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to coerce a parameter to a format usable by a specific implementation. It is up to the implementation to determine what parameter types they support. If the implementation is unable to perform coercion, it must return nil. Implementations must also be able to coerce valid scalar values (presumably to themselves...)">PCoercion</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L149">149</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support broadcasting over one or more dimensions.">PBroadcast</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L158">158</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to allow conversion to Clojure-friendly vector format. Optional for implementers.">PConversion</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L172">172</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to reshape matrices. Must support any new shape allowed by the implementation. Must preserve row-major ordering of matrix elements. If the original matrix is mutable, must return a new mutable copy of data. If the new shape has less elements than the original shape, it is OK to truncate the remaining elements. If the new shape requires more elements than the original shape, should throw an exception.">PReshaping</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L176">176</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support getting slices of an array. If implemented, must return either a view, a scalar or an immutable sub-matrix: it must *not* return copied data. i.e. making a full copy must be avoided.">PMatrixSlices</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L184">184</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for getting a sub-vector view of a vector. Must return a mutable view if the original vector is mutable. Should throw an exception if the specified subvector is out of bounds for the target vector.">PSubVector</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L192">192</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol for quick view access into a row-major slices of an array. If implemented, must return either a view or an immutable sub-matrix: it must *not* return copied data. If the matrix is mutable, it must return a mutable view. The default implementation creates a wrapper view.">PSliceView</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L198">198</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Returns the row-major slices of the matrix as a sequence. These must be views or immutable sub-arrays. The default implementation uses get-major-slice-view to obtain the slices.">PSliceSeq</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L207">207</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for concatenating / joining arrays.">PSliceJoin</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L212">212</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for picking out subsections of a matrix. Should return a mutable view if possible. The default implementation creates a new vector containing the diagonal values.">PMatrixSubComponents</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L217">217</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for assigning values to mutable matrices.">PAssignment</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L223">223</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span>PMutableFill</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L233">233</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for getting data as a double array">PDoubleArrayOutput</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L238">238</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for matrix equality operations">PMatrixEquality</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L247">247</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support matrix multiplication on an arbitrary matrix, vector or scalar. Implementation may return nil if the implementation does not support one of the parameters, in which case a more general inner-product operation will be attempted.">PMatrixMultiply</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L255">255</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for general inner and outer products of matrices. Products should use + and * as normally defined for numerical types">PMatrixProducts</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L263">263</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for add-product operation.">PAddProduct</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L269">269</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for mutable add-product! operation.">PAddProductMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L273">273</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for add-product operation.">PAddScaledProduct</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L277">277</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for mutable add-product! operation.">PAddScaledProductMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L281">281</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for add-product operation.">PAddScaled</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L285">285</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for mutable add-product! operation.">PAddScaledMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L289">289</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support element-wise division operator. One-arg version returns the reciprocal of all elements.">PMatrixDivide</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L293">293</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support mutable matrix multiplication on an arbitrary matrix, vector or scalar">PMatrixMultiplyMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L300">300</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support transformation of a vector to another vector. Is equivalent to matrix multiplication when 2D matrices are used as transformations. But other transformations are possible, e.g. affine transformations. A transformation need not be a core.matrix matrix: other types are permissible">PVectorTransform</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L305">305</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support matrix scaling by scalar values. Provided because matrix classes may have efficient specialised scaling operaions.">PMatrixScaling</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L314">314</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support mutable matrix scaling by scalar values.">PMatrixMutableScaling</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L323">323</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support matrix addition and subtraction on arbitrary matrices">PMatrixAdd</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L328">328</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support matrix addition on any matrices of same size">PMatrixAddMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L333">333</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to get a submatrix of another matrix. dim-ranges should be a sequence of [start len] pairs, one for each dimension. If a pair is nil, it should be interpreted to take the whole dimension.">PSubMatrix</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L338">338</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to compute a matrix by calling a function on each indexed location. The function f will be called as (f x y z ...) for all index values.">PComputeMatrix</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L343">343</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for matrix transpose operation">PTranspose</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L348">348</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support common vector operations.">PVectorOps</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L357">357</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span>PVectorCross</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L368">368</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span>PVectorDistance</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L374">374</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span>PVectorView</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L378">378</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span>PVectorisable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L383">383</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for mutable versions of commn vector operations">PMutableVectorOps</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L388">388</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support common matrix operations">PMatrixOps</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L392">392</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span>PNegation</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L402">402</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support computing the rank (number of linearly independent rows) ina matrix">PMatrixRank</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L406">406</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support the summing of all elements in an array. The array must hold numeric values only, or an exception will be thrown.">PSummable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L411">411</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support the 'pow' function. Should raise every element of a matrix to a given exponent. Default implementation uses Java's Math/pow function which is appropriate for double values: arrays supporting arbitrary precision numbers or complex types will need to provide their own implementation.">PExponent</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L416">416</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support element-wise squaring of an array.">PSquare</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L423">423</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support mathematic functions applied element-wise to a matrix">PMathsFunctions</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L429">429</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support mutable mathematic functions applied element-wise to a matrix">PMathsFunctionsMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L434">434</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to return the total count of elements in matrix. Result may be any integer type.">PElementCount</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L439">439</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to allow functional-style operations on matrix elements.">PFunctionalOperations</span>&nbsp;<small>(line <a href="https://github.com/mikera/matrix-api/blob/6bdb29ad4662d8845e923a2d69abfeb0c5e42c21/src/main/clojure//home/si14/projects/gsoc2013/matrix-api/src/main/clojure/clojure/core/matrix/protocols.clj#L443">443</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table></div></div></body></html></html>